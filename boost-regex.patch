--- ./boost/regex/v4/basic_regex_parser.hpp.orig	2008-01-16 21:09:57.000000000 +0100
+++ ./boost/regex/v4/basic_regex_parser.hpp	2008-01-16 21:08:30.000000000 +0100
@@ -727,7 +727,8 @@
          ++m_position;
       }
    }
-   if(0 == this->m_last_state)
+   if(0 == this->m_last_state
+      || this->m_last_state->type == syntax_element_assert_backref)
    {
       fail(regex_constants::error_badrepeat, ::boost::re_detail::distance(m_base, m_position));
       return false;
@@ -767,6 +768,7 @@
       case syntax_element_restart_continue:
       case syntax_element_jump:
       case syntax_element_startmark:
+      case syntax_element_backstep:
          // can't legally repeat any of the above:
          fail(regex_constants::error_badrepeat, m_position - m_base);
          return false;
@@ -1853,6 +1855,7 @@
    if(markid == -4)
    {
       re_syntax_base* b = this->getaddress(expected_alt_point);
+      // Make sure we have exactly one alternative following this state:
       if(b->type != syntax_element_alt)
       {
          re_alt* alt = static_cast<re_alt*>(this->insert_state(expected_alt_point, syntax_element_alt, sizeof(re_alt)));
@@ -1863,6 +1866,15 @@
          fail(regex_constants::error_bad_pattern, m_position - m_base);
          return false;
       }
+      // check for invalid repetition of next state:
+      b = this->getaddress(expected_alt_point);
+      b = this->getaddress(static_cast<re_alt*>(b)->next.i, b);
+      if((b->type != syntax_element_assert_backref)
+         && (b->type != syntax_element_startmark))
+      {
+         fail(regex_constants::error_badrepeat, m_position - m_base);
+         return false;
+      }
    }
    //
    // append closing parenthesis state:
